## 简绍

如标题所示，我构思了一种基于2.75进制的虚拟机。最初是从3进制开始，经过2.5进制，现在发展到了2.75进制。

## 原理

通过不断将一个十进制数据除以2.75并取余，将这些余数倒序拼接起来，就可以将十进制数表示2.75进制里的数。例如，1 -> (1)，2 -> (2)。由于2.75小于3，所以只能使用0、1、2这几个整数。我采用括号“()”来分隔每一位，因为在2.75进制中，每一位可能是小数，例如3 -> (1)(0.25)，4 -> (1)(1.25)，5 -> (1)(2.25)。

通过计算机遍历，可以得出以下结果： 
1 -> (1)
2 -> (2) 
3 -> (1)(0.25) 
4 -> (1)(1.25) 
5 -> (1)(2.25) 
6 -> (2)(0.5) 
7 -> (2)(1.5) 
8 -> (2)(2.5) 
9 -> (1)(0.25)(0.75) 
10 -> (1)(0.25)(1.75) 
11 -> (1)(1.25)(0)

该结果由以下程序生成：
```python
# 小数及整数进制转换.py
from decimal import Decimal

# 将数字转换为进制
def turn_into(num,Base):
    # 将输入的数字转换为Decimal类型
    divisor = Decimal(num)
    # 定义余数
    remainder = None
    # 定义连接符
    connect = []
    # 当除数不为0时，循环
    while divisor != 0:
        # 将除数和进制数相除，得到余数
        remainder = Decimal(str(divisor)) % Decimal(str(Base))
        # 将除数和进制数相除，得到商
        divisor = Decimal(str(divisor)) // Decimal(str(Base))
        # 将右括号添加到连接符列表
        connect.append(')')
        # 将余数添加到连接符列表
        connect.append(str(remainder))
        # 将左括号添加到连接符列表
        connect.append('(')
    # 如果连接符列表为空，返回左括号和0，防止空列表报错
    if len(connect) == 0: return ['(','0',')']
    # 否则，返回连接符列表反转后的值
    else: return connect[::-1]
  
# 主循环
while True:
    # 设置进制为2.75
    base = 2.75
    # 获取用户输入的数字
    num = input('数字：')
  
    # 打印数字
    print(num + ' -> ', end='')
    # 将数字转换为进制并打印
    sa = turn_into(num , base)
    for i in sa:
        print(i,end='')
    # 打印换行符
    print()
```

因此，可以通过类似16进制的方式，将这些小数表示出来，例如： 
0.25 <=> g 
1.25 <=> h 
2.25 <=> i 
0.5 <=> j 
1.5 <=> k 
2.5 <=> l 
0.75 <=> m 
1.75 <=> n

这样就可以使用一个字符来表示每一位了。因为从0到n一共有10个字符，所以2.75进制可以类似看作11进制。在底层可以用4个位来表示2.75进制里的一个位，则四个二进制位表示一个2.75进制位。尽管会占用更多数据，但用2.75进制表示整数是可行的。

而小数由于2.75进制中每一位相当于2.75的负数次幂，因此很难直接表示十进制小数。不过，可以通过保存整数部分和小数点位置来保存小数，这样也不会产生浮点误差。